package com.realtimeaudio

import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.Promise
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReadableMap
import com.facebook.react.bridge.WritableMap
import com.facebook.react.modules.core.DeviceEventManagerModule

/**
 * IMPORTANT:
 * Do NOT declare NativeRealtimeAudioAnalyzerSpec yourself.
 * This class is generated by RN Codegen based on your TS Spec.
 *
 * After codegen runs, it will be available in this package:
 *   com.realtimeaudio.NativeRealtimeAudioAnalyzerSpec
 */
class RealtimeAudioAnalyzerModule(
  reactContext: ReactApplicationContext
) : NativeRealtimeAudioAnalyzerSpec(reactContext) {

  companion object {
    const val NAME = "RealtimeAudioAnalyzer"
  }

  private val engine = AudioEngine { data -> sendEvent(data) }

  override fun getName(): String = NAME

  override fun startAnalysis(config: ReadableMap, promise: Promise) {
    try {
      val bufferSize = if (config.hasKey("fftSize")) config.getInt("fftSize") else 1024
      val sampleRate = if (config.hasKey("sampleRate")) config.getInt("sampleRate") else 44100
      val callbackRateHz = 30
      val emitFft = true

      engine.start(bufferSize, sampleRate, callbackRateHz, emitFft)
      promise.resolve(null)
    } catch (e: SecurityException) {
      promise.reject("E_PERMISSION_DENIED", "Microphone permission denied: ${e.message}", e)
    } catch (e: Exception) {
      promise.reject("E_START_FAILED", e.message ?: "Unknown error occurred", e)
    }
  }

  override fun stopAnalysis(promise: Promise) {
    engine.stop()
    promise.resolve(null)
  }

  override fun isAnalyzing(promise: Promise) {
    promise.resolve(engine.isRecording())
  }

  override fun getAnalysisConfig(promise: Promise) {
    val config = Arguments.createMap().apply {
      putInt("fftSize", 1024)
      putInt("sampleRate", 44100)
      putString("windowFunction", "hanning")
      putDouble("smoothing", 0.8)
    }
    promise.resolve(config)
  }

  // Legacy aliases (if in your TS Spec)
  override fun start(options: ReadableMap, promise: Promise) =
    startAnalysis(options, promise)

  override fun stop(promise: Promise) =
    stopAnalysis(promise)

  override fun isRunning(promise: Promise) =
    isAnalyzing(promise)

  override fun setSmoothing(enabled: Boolean, factor: Double, promise: Promise) {
    engine.setSmoothing(enabled, factor.toFloat())
    promise.resolve(null)
  }

  override fun setFftConfig(fftSize: Double, downsampleBins: Double, promise: Promise) {
    engine.setFftConfig(fftSize.toInt(), downsampleBins.toInt())
    promise.resolve(null)
  }

  override fun addListener(eventName: String) { /* required by RN */ }
  override fun removeListeners(count: Double) { /* required by RN */ }

  private fun sendEvent(data: AudioEngine.AudioData) {
    // Use the supported API; hasActiveCatalystInstance is deprecated
    if (!reactApplicationContext.hasActiveReactInstance()) return

    fun params(): WritableMap =
      Arguments.createMap().apply {
        putDouble("timestamp", data.timestamp)
        putDouble("volume", data.rms)
        putDouble("peak", data.peak)
        putInt("sampleRate", data.sampleRate)
        putInt("fftSize", data.bufferSize)

        val freq = Arguments.createArray()
        data.fft?.forEach { freq.pushDouble(it.toDouble()) }
        putArray("frequencyData", freq)
        putArray("timeData", Arguments.createArray())
      }

    reactApplicationContext
      .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
      .emit("RealtimeAudioAnalyzer:onData", params())
  }
}